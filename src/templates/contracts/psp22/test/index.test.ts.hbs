import { expect, use } from "chai";
import chaiAsPromised from "chai-as-promised";
import {{contract_name_pascal}}Factory from "../../typedContracts/{{contract_name}}/constructors/{{contract_name}}";
import {{contract_name_pascal}} from "../../typedContracts/{{contract_name}}/contracts/{{contract_name}}";
import { ApiPromise, WsProvider, Keyring } from "@polkadot/api";
import { KeyringPair } from "@polkadot/keyring/types";

use(chaiAsPromised);

// Create a new instance of contract
const wsProvider = new WsProvider("ws://127.0.0.1:9944");
// Create a keyring instance
const keyring = new Keyring({ type: "sr25519" });

const EMPTY_ADDRESS = "5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM";
describe("{{contract_name}} test", () => {
  let {{contract_name}}Factory: {{contract_name_pascal}}Factory;
  let api: ApiPromise;
  let deployer: KeyringPair;
  let wallet1: KeyringPair;
  let wallet2: KeyringPair;
  let contract: {{contract_name_pascal}};
  const maxSupply = 10000000000;

  before(async function setup(): Promise<void> {
    api = await ApiPromise.create({ provider: wsProvider });
    deployer = keyring.addFromUri("//Alice");
    wallet1 = keyring.addFromUri("//Bob");
    wallet2 = keyring.addFromUri("//Charlie");

    {{contract_name}}Factory = new {{contract_name_pascal}}Factory(api, deployer);

    contract = new {{contract_name_pascal}}(
      (await {{contract_name}}Factory.new(maxSupply)).address,
      deployer,
      api
    );
  });

  after(async function tearDown() {
    await api.disconnect();
  });

  it("Assigns initial balance", async () => {
    expect(
      (await contract.query.totalSupply()).value.ok?.rawNumber.toNumber()
    ).to.equal(maxSupply);
  });

  it("Transfer adds amount to destination account", async () => {
    const transferredAmount = 2;

    const { gasRequired } = await contract
      .withSigner(deployer)
      .query.transfer(wallet1.address, transferredAmount, []);

    await contract.tx.transfer(wallet1.address, transferredAmount, [], {
      gasLimit: gasRequired,
    });

    await expect(
      (await contract.query.balanceOf(wallet1.address)).value.ok?.toNumber()
    ).to.be.equal(transferredAmount);
    await expect(
      (await contract.query.balanceOf(contract.signer.address)).value.ok?.toNumber()
    ).to.be.equal(maxSupply - transferredAmount);
  });

  it("Can not transfer above the amount", async () => {
    const transferredAmount = maxSupply + 1;

    const { gasRequired } = await contract
      .withSigner(deployer)
      .query.transfer(wallet1.address, transferredAmount, []);

    await expect(
      contract.tx.transfer(wallet1.address, transferredAmount, [], {
        gasLimit: gasRequired,
      })
    ).to.eventually.be.rejected;
  });
});